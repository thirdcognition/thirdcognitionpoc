from fuzzywuzzy import fuzz
import textwrap
from typing import Dict, List, Optional, Tuple, Union
from pydantic import BaseModel, Field

# from langchain_core.documents import Document
# from langchain_core.prompts.few_shot import FewShotPromptTemplate
# from langchain_core.prompts.prompt import PromptTemplate
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import (
    SystemMessage,
    BaseMessage,
)
from langchain_core.prompts.chat import MessagesPlaceholder, HumanMessagePromptTemplate
from langchain_core.output_parsers.base import BaseOutputParser
from langchain_core.exceptions import OutputParserException
from langchain_core.output_parsers import BaseOutputParser

from lib.helpers import pretty_print

# from fewshot_data import FewShotItem, example_tasks

PRE_THINK_INSTRUCT = """
        Reason through the query inside <thinking> tags, and then provide your final response inside <output> tags.
        If you detect that you made a mistake in your reasoning at any point, correct yourself inside <reflection> tags.
        """
PRE_THINK_TAGS = ["thinking", "reflection"]
SUMMARIZE_INSTRUCT = """
        Use <thinking>-tag to identify different topics that are contained within the page. Explain your reasoning using
        <reflect>-tag and make sure to cover all topics separately.

        For each topic write content that contains all the information about the topic that is available within the context.
        Use the <output>-tag to wrap the content, add <topic>-tag to specify the topic and <summary>-tag to specify the summary of the content.
        Use following format for each topic:
        <output>
        <topic>
        Topic
        </topic>
        Formatted content in full detail.
        <summary>
        Summary of the content
        </summary>
        </output>

        If the content specifies multiple topics be sure to add a <topic>, <output> and <summary> for each topic.
        Finally after writing <output>-tag for each topic, write a final <output>-tag with specified format
        that covers the whole content within the context in full detail. If there's Previous or Next page defined
        do not consider this to cover all content but just one slice of it.
        Always use <[tag]> and </[tag]>-tags, e.g. <topic> and </topic> when tags are specified.
        """
SUMMARIZE_INSTRUCT_TAGS = ["topic", "summary"]
ACTOR_INTRODUCTIONS = "You are a world-class AI system, capable of complex reasoning and reflection called Virtual Buddy."
# For example:

# Example 1:

# <thinking> I have a long article about a recent scientific discovery. I will generate a summary
# that highlights the main findings, the method used, and the implications of the discovery. </thinking>

# A recent study published in the Journal of Neuroscience revealed that prolonged exposure to blue light
# before sleep can disrupt circadian rhythms and lead to sleep disorders. The research, conducted on mice,
# found that blue light exposure suppressed the production of melatonin, a hormone that regulates sleep-wake cycles.
# These findings suggest that limiting blue light exposure, particularly in the evening, may help improve sleep
# quality and reduce the risk of sleep disorders.

# Example 2:

# <thinking> I have a lengthy book review. I will create a summary that captures the main points of the book,
# the author's style, and the reviewer's overall opinion. </thinking>

# In 'The Catcher in the Rye', J.D. Salinger explores the disillusionment and alienation of a teenager named Holden Caulfield.
# Through Holden's first-person narrative, the novel delves into themes of adolescence, identity, and the struggle for authenticity.
# The book's raw and unfiltered language captures the angst and confusion of youth, making it a classic of modern literature.

# Example 3:

# <thinking> I have several research papers on a specific topic. I will generate a comprehensive report that synthesizes
# the findings from each paper, identifies common themes, and discusses any discrepancies. </thinking>

# A comprehensive analysis of the effects of climate change on global food security was conducted by synthesizing data from
# multiple research papers. The synthesis revealed that climate change is likely to have a significant negative impact on food
# security, particularly in low-income countries. The findings indicated that increased temperatures, droughts, and sea-level
# rise will lead to reduced crop yields, increased food prices, and food insecurity. However, the report also highlighted potential
# adaptation strategies and the importance of international cooperation to mitigate the risks associated with climate change.
# """
KEEP_PRE_THINK_TOGETHER = """
        While following your plan don't explain what you are doing.
        """

MAINTAIN_CONTENT_AND_USER_LANGUAGE = """
        Maintain the content and the language of the input and always output in the language used in context and history.
        """


class PromptFormatter(BaseModel):
    system: str = Field(description="The system message template")
    user: str = Field(description="The user message template")
    parser: Optional[BaseOutputParser] = Field(
        description="The parser for response", default=None
    )

    def customize(
        self, system: Optional[str] = None, user: Optional[str] = None
    ) -> "PromptFormatter":
        return PromptFormatter(
            system=system if system is not None else self.system,
            user=user if user is not None else self.user,
            parser=self.parser,
        )

    def format(
        self,
        system_format: Optional[Tuple[str, str]] = None,
        user_format: Optional[Tuple[str, str]] = None,
        system: Optional[str] = None,
        user: Optional[str] = None,
        use_format: bool = False,
    ) -> "PromptFormatter":
        """
        Format the system and user messages with optional prefix and suffix.

        Args:
            system_format (Optional[Tuple[str, str]]): The prefix and suffix for the system message.
            user_format (Optional[Tuple[str, str]]): The prefix and suffix for the user message.
            system (Optional[str]): The system message. If not provided, the default system message is used.
            user (Optional[str]): The user message. If not provided, the default user message is used.
            use_format (bool): Whether to use the provided prefix and suffix.

        Returns:
            PromptFormatter: A new PromptFormatter instance with the formatted messages.
        """
        if system is None:
            system = self.system
        if user is None:
            user = self.user

        if (not use_format) or (system_format is None and user_format is None):
            return PromptFormatter(system=system, user=user)
        else:
            system_prefix, system_suffix = system_format if system_format else ("", "")
            user_prefix, user_suffix = user_format if user_format else ("", "")
            formatted_system = system_prefix + system + system_suffix
            formatted_user = user_prefix + user + user_suffix
            return PromptFormatter(system=formatted_system, user=formatted_user)

    def get_agent_prompt_template(
        self, custom_system: Optional[str] = None, custom_user: Optional[str] = None
    ) -> ChatPromptTemplate:
        prompt = ChatPromptTemplate.from_messages(
            [
                ("system", custom_system or self.system),
                MessagesPlaceholder(variable_name="chat_history", optional=True),
                ("user", custom_user or self.user),
                # MessagesPlaceholder(variable_name="agent_scratchpad", optional=True),
            ]
        )
        if self.parser is not None:
            prompt.partial_variables["format_instructions"] = (
                self.parser.get_format_instructions()
            )

        return prompt

    def get_chat_prompt_template(
        self, custom_system: Optional[str] = None, custom_user: Optional[str] = None
    ) -> ChatPromptTemplate:
        prompt = ChatPromptTemplate.from_messages(
            [
                SystemMessage(content=custom_system or self.system),
                MessagesPlaceholder(variable_name="chat_history", optional=True),
                HumanMessagePromptTemplate.from_template(custom_user or self.user),
            ]
        )
        if self.parser is not None and (
            "format_instructions" in self.system or "format_instructions" in self.user
        ):
            prompt.partial_variables["format_instructions"] = (
                self.parser.get_format_instructions()
            )

        return prompt

    def get_prompt_format(self) -> str:
        return self.parser.get_format_instructions()


from html.parser import HTMLParser


class TagHTMLParser(HTMLParser):
    def __init__(self, allowed_tags):
        super().__init__()
        self.allowed_tags = allowed_tags
        self.stack = []
        self.root = None

    def reset(self):
        self.stack = []
        self.root = None
        super().reset()

    def handle_starttag(self, tag, attrs):
        for allowed_tag in self.allowed_tags:
            if fuzz.ratio(tag, allowed_tag) > 80:
                new_node = {"tag": tag, "body": "", "children": []}
                if self.stack:
                    self.stack[-1]["children"].append(new_node)
                else:
                    self.root = new_node
                self.stack.append(new_node)

    def handle_endtag(self, tag):
        if self.stack:
            if fuzz.ratio(tag, self.stack[-1]["tag"]) > 80:
                self.stack.pop()

    def handle_data(self, data):
        if self.stack and len(str(data).strip()) > 0:
            self.stack[-1]["body"] += (
                data.strip() + "\n\n" if isinstance(data, str) else data
            )

    def get_root(self):
        return self.root


def parse_html(html, allowed_tags):
    parser = TagHTMLParser(allowed_tags)
    parser.feed(html)
    return parser.get_root()


class TagsParser(BaseOutputParser[Union[str, Dict]]):
    """Custom parser to clean specified tag from results."""

    min_len: int = 10
    tags = ["thinking", "reflection"]
    content_tags = ["root", "output"]
    optional_tags: List[str] = None
    return_tag: bool = False
    all_tags_required: bool = False

    def get_child_content(self, node, tags=None) -> str:
        if tags is None:
            tags = self.tags
        content = ""
        if node["tag"] in tags:
            content = str(node["body"]).strip() + "\n"
        for child in node["children"]:
            content += self.get_child_content(child, tags).strip() + "\n"
        return content.strip()

    def parse(self, text: Union[str, BaseMessage]) -> Union[str, Dict]:
        tag_html_parser = TagHTMLParser(
            (
                self.tags + self.optional_tags
                if isinstance(self.optional_tags, list)
                else self.tags
            )
            + self.content_tags
        )

        # print(f"Parsing tags: {text}")
        if isinstance(text, BaseMessage):
            text = text.content

        if isinstance(text, str):
            text = text.strip()

        tag_html_parser.feed(
            f"<root>{text}</root>"
            if not text.startswith("<root>") or not text.startswith("<output>")
            else text
        )
        parsed_content = tag_html_parser.get_root()

        pretty_print({"text": text, "parsed": parsed_content}, "Parsed content:")

        content = {}
        tag_contents_joined = {}

        tags = self.tags + self.content_tags
        if isinstance(self.optional_tags, list):
            tags += self.optional_tags

        for tag in tags:
            if parsed_content is not None and "children" in parsed_content:
                # content[tag] = ""
                # for node in parsed_content["children"]:
                #     if node["tag"] == tag:
                #         content[tag] += (
                content[tag] = self.get_child_content(
                        parsed_content,
                        [tag]
                        # (
                        #     self.tags + self.optional_tags
                        #     if isinstance(self.optional_tags, list)
                        #     else self.tags
                        # ),
                    ) + 2 * "\n"
                #         )
                content[tag] = content[tag].strip()
                if len(content[tag]) == 0:
                    del content[tag]
                # tag_contents_joined[tag] = (
                #     content[tag]
                #     if tag not in tag_contents_joined
                #     else tag_contents_joined[tag] + "\n\n" + content[tag]
                # )

        for tag in self.content_tags:
            if tag in content:
                del content[tag]
        #     if tag in tag_contents_joined:
        #         del tag_contents_joined[tag]

        text_contents_joined = str(parsed_content["body"]).strip()
        for node in parsed_content["children"]:
            if node["tag"] not in self.tags:
                text_contents_joined += (
                    self.get_child_content(node, self.content_tags) + 2 * "\n"
                )
        text_contents_joined = text_contents_joined.strip()


        if (
            self.min_len > 0
            and len(repr(content)) > 2
            and len(text_contents_joined) == 0
        ):
            found_tags = content.keys()

            excpect_msg = textwrap.dedent(
                f"""
            Expected a response but got only:
            {",\n ".join([f"<{tag}> .... </{tag}>" for tag in found_tags])}>
            response{"" if len(found_tags) == 1 else "s"}. Please make sure that the response is long enough
            and also contains text outside of the tags.
            """
            )
        elif len(text_contents_joined) < self.min_len:
            excpect_msg = textwrap.dedent(
                f"""
            Expected a response message at least {self.min_len} characters long.
            Please make sure that the response is long enough.
            """
            )

            raise OutputParserException(excpect_msg)

        if self.all_tags_required:
            missing_tags = []
            for tag in self.tags:
                if tag not in content or len(content[tag]) == 0:
                    missing_tags.append(tag)

            if len(missing_tags) > 0:
                raise OutputParserException(
                    f"Expected a response with all tags: {', '.join(self.tags)}\nMissing tags: {', '.join(missing_tags)}"
                )

        if self.return_tag:
            resp = {
                "content": text_contents_joined,
                "tags": {tag: content[tag] for tag in self.tags},
                # "tags_joined": tag_contents_joined,
                "parsed": parsed_content,
            }
            pretty_print(resp, "Tag parser response:")
            return resp
        else:
            return text_contents_joined

    @property
    def _type(self) -> str:
        return "tag_output_parser"


# def generate_result_sample(tasks: List[FewShotItem], amount = 3) -> dict:
#     sample = random.sample(tasks, amount)
#     documents = [Document(page_content=task.document) for task in sample]
#     result = "\n".join([f"Task {i+1}:\n{task.result}" for i, task in enumerate(sample)])
#     return {"documents": documents, "result": result}

# def get_journey_format_example(amount=4) -> FewShotPromptTemplate:
#     instruction = textwrap.dedent(
#         """
#         Find tasks from the following documents and create a task list based on it.

#         Documents:
#         {documents}

#         Task:
#         {tasks}
#     """
#     )

#     task_lists = [lambda: generate_result_sample(example_tasks, amount) for _ in range(3)]

#     return FewShotPromptTemplate(
#         examples=task_lists,
#         example_prompt=PromptTemplate(
#             template=instruction,
#             input_variables=["documents", "tasks"],
#         ),
#         suffix=textwrap.dedent(
#             """
#             Documents:
#             {context}
#             """),
#         input_variables=["context"],
#     )
